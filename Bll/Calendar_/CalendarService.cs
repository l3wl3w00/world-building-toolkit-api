using AutoMapper;
using AutoMapper.QueryableExtensions;
using Bll.Calendar_.Dto;
using Bll.Common.Exception;
using Bll.Common.Extension;
using Bll.Common.Option_;
using Bll.Common.Result_;
using Bll.Event_.Dto;
using Bll.Planet_;
using Dal;
using Dal.Entities;
using Google.Apis.Util;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace Bll.Calendar_;

public class CalendarService(
    WorldBuilderDbContext dbContext, 
    IMapper mapper, 
    IPlanetQueryService planetQueryService) : ICalendarService
{
    private const string DefaultCalendarName = "Default"; 
    public async Task<Result<CalendarDto>> Create(Guid planetId, CreateCalendarDto calendarDto)
    {
        var planetOpt = await planetQueryService.GetWithCalendarsIncludedOrOption(planetId);
        
        if (planetOpt.NoValueOut(out var planet)) return EntityNotFoundException.CreateResult<CalendarDto, Planet>(planetId);
        
        var calendarWithNameAlreadyExists = planet!.Calendars.Any(c => c.Name == calendarDto.Name);
        if (calendarWithNameAlreadyExists)
        {
            return EntityAlreadyExistsException
                .CreateWithMessage<Calendar>($"There already exists a calendar " +
                                             $"on planet {planet.Name} " +
                                             $"with the name {calendarDto.Name} ")
                .ToErrorResult<CalendarDto>();
        }
        
        var calendar = mapper.Map<Calendar>(calendarDto);
        var invalidYearPhases = !calendar.AreYearPhasesValidForPlanet(planet);
        if (invalidYearPhases) return new InvalidYearPhasesException(calendar, planet).ToErrorResult<CalendarDto>();
        
        calendar.PlanetId = planetId;
        
        dbContext.Calendars.Add(calendar);
        
        await dbContext.SaveChangesAsync();

        return mapper.Map<CalendarDto>(calendar).ToOkResult();

    }

    public async Task<Option<CalendarDto>> GetDefault(Guid planetId)
    {
        var result = await Get(planetId, DefaultCalendarName);
        if (result.IsErrorOf<EntityNotFoundException>()) return Option<CalendarDto>.None;
        return result.OkValueOpt.NullOr<CalendarDto>(v => v.Map<CalendarDto>(mapper));
    }

    public async Task<Result<CalendarDto>> CreateDefaultForPlanet(Planet planet)
    {
        var createDto = new CreateCalendarDto
        (
            Name: DefaultCalendarName,
            Description: "This is the calendar generated by default for every planet",
            FirstYear: 0,
            YearPhases: new List<YearPhase>
            {
                new("Single Phase", planet.NumberOfDaysInYear)
            }
        );
        
        return await Create(planet.Id, createDto);
    }
    
    public async Task<Result<CalendarDto>> Get(Guid calendarId)
    {
        return (await dbContext.Calendars
            .Where(c => c.Id == calendarId)
            .ProjectTo<CalendarDto>(mapper.ConfigurationProvider)
            .SingleOrOptionAsync())
            .ValueOrEntityNotFoundException();
    }

    public async Task<Result<Calendar>> GetEntity(Guid calendarId)
    {
        return (await dbContext.Calendars
                .Where(c => c.Id == calendarId)
                .Include(c => c.Planet)
                .SingleOrOptionAsync())
            .ValueOrEntityNotFoundException();
    }
    
    public async Task<ICollection<CalendarDto>> GetAllForPlanet(Guid planetId)
    {
        return await dbContext.Calendars.ProjectTo<CalendarDto>(mapper.ConfigurationProvider).ToListAsync();
    }

    public async Task<Result<CalendarDto>> Delete(Guid planetId, string calendarToDeleteName)
    {
        var planetOpt = await planetQueryService.GetWithCalendarsIncludedOrOption(planetId);
        if (planetOpt.NoValueOut(out var planet)) return EntityNotFoundException.CreateResult<CalendarDto, Planet>(planetId);

        var noCalendarToDelete = planet!.Calendars
            .SingleOrDefault(c => c.Name == calendarToDeleteName)
            .ToOption()
            .NoValueOut(out var calendarToDelete);
        if (noCalendarToDelete) return EntityNotFoundException.CreateResult<CalendarDto, Calendar>();
        
        await dbContext.Calendars
            .Where(c => c.Id == calendarToDelete!.Id)
            .ExecuteDeleteAsync();
        return mapper.Map<CalendarDto>(calendarToDelete).ToOkResult();
    }

    public async Task<Result<GlobalTimeInstance>> ResolveDate(Guid calendarId, DateInstanceDto date)
    {
        var calendarResult = await GetEntity(calendarId);
        if (calendarResult.IsErrorOut(out var calendar)) return calendarResult.Into<GlobalTimeInstance>();
        var relativeTime = new RelativeTimeInstance(date.Year, date.YearPhase, date.Day, date.Hour, date.Minute);
        return calendar!.ToGlobal(relativeTime).ToOkResult();
    }

    public async Task<Result<DateInstanceDto>> Convert(
        Guid planetId,
        string sourceCalendarName,
        string targetCalendarName,
        DateInstanceDto date)
    {
        var sourceCalendarResult = await Get(planetId, sourceCalendarName);
        if (sourceCalendarResult.IsErrorOut(out var sourceCalendar))
        {
            return sourceCalendarResult.Into<DateInstanceDto>();
        }
        
        var targetCalendarResult = await Get(planetId, targetCalendarName);
        if (targetCalendarResult.IsErrorOut(out var targetCalendar))
        {
            return targetCalendarResult.Into<DateInstanceDto>();
        }

        var relativeTimeToSource = mapper.Map<RelativeTimeInstance>(date);
        var globalTime = sourceCalendar!.ToGlobal(relativeTimeToSource);
        var relativeTimeToTarget =  targetCalendar!.ToRelative(globalTime);

        return mapper.Map<DateInstanceDto>(relativeTimeToTarget).ToOkResult();
    }

    private async Task<Result<Calendar>> Get(Guid planetId, string calendarName)
    {
        var result = await GetWithPlanet(planetId, calendarName);
        return result.ErrorOr(v => v.Item1);
    }
    
    private async Task<Result<(Calendar, Planet)>> GetWithPlanet(Guid planetId, string calendarName)
    {
        var planetOpt = await planetQueryService.GetWithCalendarsIncludedOrOption(planetId);
        if (planetOpt.NoValueOut(out var planet)) return EntityNotFoundException.CreateResult<(Calendar, Planet), Planet>(planetId);
        
        var calendarOpt = planet!.Calendars
            .SingleOrDefault(c => c.Name == calendarName)
            .ToOption();
        if (calendarOpt.NoValueOut(out var calendar))
            return EntityNotFoundException.Create<Calendar>().ToErrorResult<(Calendar, Planet)>();

        return (calendar!, planet).ToOkResult();
    }
}

public static class CalendarUtils
{
    const ulong SecondsInHour = 60ul * 60ul;
    const ulong SecondsInMinute = 60ul;
    
    // This method expects the Planet to not be null
    public static GlobalTimeInstance ToGlobal(this Calendar calendar, RelativeTimeInstance relativeTimeInstance)
    {
        var days = (uint) calendar.YearPhases
            .TakeWhile(phase => phase.Name != relativeTimeInstance.YearPhase)
            .Sum(phase => phase.NumberOfDays) + relativeTimeInstance.Day;
        
        var secondsInPastYears = relativeTimeInstance.Year - 
                                 calendar.FirstYear * 
                                 (ulong) calendar.Planet.YearLength.Seconds;
        var secondsInCurrentYear = 
            days * (ulong) calendar.Planet.DayLength.Seconds +
            relativeTimeInstance.Hour * SecondsInHour + 
            relativeTimeInstance.Minute * SecondsInMinute;
        
        var seconds = secondsInPastYears + secondsInCurrentYear;
        return new GlobalTimeInstance(seconds);
    }
    
    public static RelativeTimeInstance ToRelative(this Calendar calendar, GlobalTimeInstance globalTime)
    {
        var years = globalTime.WholeYears(calendar.Planet);
        var dayOfYear = globalTime.WholeDaysInYear(calendar.Planet);
        var yearPhase = calendar.GetYearPhase(dayOfYear);
        var dayOfMonth = dayOfYear - yearPhase.DaysBefore(calendar.YearPhases);
        
        var hourOfDay = globalTime.WholeHoursInDay(calendar.Planet);
        var minuteOfHour = (uint) globalTime.MinutesInHour;
        return new RelativeTimeInstance(years, yearPhase.Name, dayOfMonth, hourOfDay, minuteOfHour);
    }

    private static YearPhase GetYearPhase(this Calendar calendar, decimal dayOfYear)
    {
        var dayCount = 0L;
        foreach (var yearPhase in calendar.YearPhases)
        {
            dayCount += yearPhase.NumberOfDays;
            if (dayCount >= dayOfYear)
            {
                return yearPhase;
            }
        }

        throw new Exception($"Day of year: {dayOfYear} is more than the number of days allowed in a year");
    }
}

public class InvalidYearPhasesException : Exception
{
    private readonly Calendar _calendar;
    private readonly Planet _planet;

    public InvalidYearPhasesException(Calendar calendar, Planet planet) : base("Year phases are invalid for planet. ")
    {
        _calendar = calendar;
        _planet = planet;
    }
}